% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/layers_conv.R
\name{layer_edge_conditioned_conv}
\alias{layer_edge_conditioned_conv}
\title{EdgeConditionedConv}
\usage{
layer_edge_conditioned_conv(
  object,
  channels,
  kernel_network = NULL,
  root = TRUE,
  activation = NULL,
  use_bias = TRUE,
  kernel_initializer = "glorot_uniform",
  bias_initializer = "zeros",
  kernel_regularizer = NULL,
  bias_regularizer = NULL,
  activity_regularizer = NULL,
  kernel_constraint = NULL,
  bias_constraint = NULL,
  ...
)
}
\arguments{
\item{channels}{integer, number of output channels}

\item{kernel_network}{a list of integers representing the hidden neurons of
the kernel-generating network}

\item{root}{NA}

\item{activation}{activation function to use}

\item{use_bias}{bool, add a bias vector to the output}

\item{kernel_initializer}{initializer for the weights}

\item{bias_initializer}{initializer for the bias vector}

\item{kernel_regularizer}{regularization applied to the weights}

\item{bias_regularizer}{regularization applied to the bias vector}

\item{activity_regularizer}{regularization applied to the output}

\item{kernel_constraint}{constraint applied to the weights}

\item{bias_constraint}{constraint applied to the bias vector.}
}
\description{
\loadmathjax
An edge-conditioned convolutional layer (ECC) as presented by
\href{https://arxiv.org/abs/1704.02901}{Simonovsky & Komodakis (2017)}.

\strong{Mode}: single, disjoint, batch.

\strong{Notes}:
\itemize{
\item This layer expects dense inputs and self-loops when working in batch mode.
\item In single mode, if the adjacency matrix is dense it will be converted
to a SparseTensor automatically (which is an expensive operation).
}

For each node \mjeqn{ i }{}, this layer computes:
\mjdeqn{ Z_i = X_{i} W_{\textrm{root}} + \sum\limits_{j \in \mathcal{N}(i)} X_{j} \textrm{MLP}(E_{ji}) + b }{}
where \mjeqn{\textrm{MLP}}{} is a multi-layer perceptron that outputs an
edge-specific weight as a function of edge attributes.

\strong{Input}
\itemize{
\item Node features of shape \verb{([batch], N, F)};
\item Binary adjacency matrices of shape \verb{([batch], N, N)};
\item Edge features. In single mode, shape \verb{(num_edges, S)}; in batch mode, shape
\verb{(batch, N, N, S)}.
}

\strong{Output}
\itemize{
\item node features with the same shape of the input, but the last dimension
changed to \code{channels}.
}
}
